<!DOCTYPE html>

<html lang="en">

<head>
  <title>Truncated tesseract</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <script src="../libraries/three_r140.min.js"></script>
  <script src="../libraries/OrbitControls.js"></script>
  <script src="../libraries/lil-gui.umd.js"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    #gui {
      position: absolute;
      top: 2px;
      left: 2px;
    }

    .lil-gui {
      --name-width: 30%;
      --slider-input-min-width: 25px;
      --slider-input-width: 10%;
    }
  </style>

  <script>
    // radii
    const edgeRadius = 0.035;
    const vertexRadius = 0.05;

    // vertices
    const beta = 1 + Math.sqrt(2);
    const vxnorm = Math.sqrt(1 + 3 * beta * beta); // vertex norm
    const vertices4d = [
      [-1.0, -beta, -beta, -beta],
      [-1.0, -beta, -beta, beta],
      [-1.0, -beta, beta, -beta],
      [-1.0, -beta, beta, beta],
      [-1.0, beta, -beta, -beta],
      [-1.0, beta, -beta, beta],
      [-1.0, beta, beta, -beta],
      [-1.0, beta, beta, beta],
      [1.0, -beta, -beta, -beta],
      [1.0, -beta, -beta, beta],
      [1.0, -beta, beta, -beta],
      [1.0, -beta, beta, beta],
      [1.0, beta, -beta, -beta],
      [1.0, beta, -beta, beta],
      [1.0, beta, beta, -beta],
      [1.0, beta, beta, beta],
      [-beta, -1.0, -beta, -beta],
      [-beta, -1.0, -beta, beta],
      [-beta, -1.0, beta, -beta],
      [-beta, -1.0, beta, beta],
      [-beta, 1.0, -beta, -beta],
      [-beta, 1.0, -beta, beta],
      [-beta, 1.0, beta, -beta],
      [-beta, 1.0, beta, beta],
      [beta, -1.0, -beta, -beta],
      [beta, -1.0, -beta, beta],
      [beta, -1.0, beta, -beta],
      [beta, -1.0, beta, beta],
      [beta, 1.0, -beta, -beta],
      [beta, 1.0, -beta, beta],
      [beta, 1.0, beta, -beta],
      [beta, 1.0, beta, beta],
      [-beta, -beta, -1.0, -beta],
      [-beta, -beta, -1.0, beta],
      [-beta, -beta, 1.0, -beta],
      [-beta, -beta, 1.0, beta],
      [-beta, beta, -1.0, -beta],
      [-beta, beta, -1.0, beta],
      [-beta, beta, 1.0, -beta],
      [-beta, beta, 1.0, beta],
      [beta, -beta, -1.0, -beta],
      [beta, -beta, -1.0, beta],
      [beta, -beta, 1.0, -beta],
      [beta, -beta, 1.0, beta],
      [beta, beta, -1.0, -beta],
      [beta, beta, -1.0, beta],
      [beta, beta, 1.0, -beta],
      [beta, beta, 1.0, beta],
      [-beta, -beta, -beta, -1.0],
      [-beta, -beta, -beta, 1.0],
      [-beta, -beta, beta, -1.0],
      [-beta, -beta, beta, 1.0],
      [-beta, beta, -beta, -1.0],
      [-beta, beta, -beta, 1.0],
      [-beta, beta, beta, -1.0],
      [-beta, beta, beta, 1.0],
      [beta, -beta, -beta, -1.0],
      [beta, -beta, -beta, 1.0],
      [beta, -beta, beta, -1.0],
      [beta, -beta, beta, 1.0],
      [beta, beta, -beta, -1.0],
      [beta, beta, -beta, 1.0],
      [beta, beta, beta, -1.0],
      [beta, beta, beta, 1.0]
    ];
    const nvertices = vertices4d.length;

    // edges -------------------------------------------------------------------
    const edges = [
      [0, 8],
      [0, 16],
      [0, 32],
      [0, 48],
      [1, 9],
      [1, 17],
      [1, 33],
      [1, 49],
      [2, 10],
      [2, 18],
      [2, 34],
      [2, 50],
      [3, 11],
      [3, 19],
      [3, 35],
      [3, 51],
      [4, 12],
      [4, 20],
      [4, 36],
      [4, 52],
      [5, 13],
      [5, 21],
      [5, 37],
      [5, 53],
      [6, 14],
      [6, 22],
      [6, 38],
      [6, 54],
      [7, 15],
      [7, 23],
      [7, 39],
      [7, 55],
      [8, 24],
      [8, 40],
      [8, 56],
      [9, 25],
      [9, 41],
      [9, 57],
      [10, 26],
      [10, 42],
      [10, 58],
      [11, 27],
      [11, 43],
      [11, 59],
      [12, 28],
      [12, 44],
      [12, 60],
      [13, 29],
      [13, 45],
      [13, 61],
      [14, 30],
      [14, 46],
      [14, 62],
      [15, 31],
      [15, 47],
      [15, 63],
      [16, 20],
      [16, 32],
      [16, 48],
      [17, 21],
      [17, 33],
      [17, 49],
      [18, 22],
      [18, 34],
      [18, 50],
      [19, 23],
      [19, 35],
      [19, 51],
      [20, 36],
      [20, 52],
      [21, 37],
      [21, 53],
      [22, 38],
      [22, 54],
      [23, 39],
      [23, 55],
      [24, 28],
      [24, 40],
      [24, 56],
      [25, 29],
      [25, 41],
      [25, 57],
      [26, 30],
      [26, 42],
      [26, 58],
      [27, 31],
      [27, 43],
      [27, 59],
      [28, 44],
      [28, 60],
      [29, 45],
      [29, 61],
      [30, 46],
      [30, 62],
      [31, 47],
      [31, 63],
      [32, 34],
      [32, 48],
      [33, 35],
      [33, 49],
      [34, 50],
      [35, 51],
      [36, 38],
      [36, 52],
      [37, 39],
      [37, 53],
      [38, 54],
      [39, 55],
      [40, 42],
      [40, 56],
      [41, 43],
      [41, 57],
      [42, 58],
      [43, 59],
      [44, 46],
      [44, 60],
      [45, 47],
      [45, 61],
      [46, 62],
      [47, 63],
      [48, 49],
      [50, 51],
      [52, 53],
      [54, 55],
      [56, 57],
      [58, 59],
      [60, 61],
      [62, 63]
    ];
    const nedges = edges.length;

    // tetrahedra --------------------------------------------------------------
    const tetrahedra = [
      [0, 16, 32, 48],
      [11, 27, 43, 59],
      [12, 28, 44, 60],
      [8, 24, 40, 56],
      [9, 25, 41, 57],
      [15, 31, 47, 63],
      [13, 29, 45, 61],
      [14, 30, 46, 62],
      [10, 26, 42, 58],
      [3, 19, 35, 51],
      [2, 18, 34, 50],
      [1, 17, 33, 49],
      [4, 20, 36, 52],
      [5, 21, 37, 53],
      [6, 22, 38, 54],
      [7, 23, 39, 55]
    ];    
    const ntetrahedra = tetrahedra.length; 

    // a right-isoclinic rotation ---------------------------------------------
    function rotate4d(theta, phi, alpha, x) {
      const x0 = x[0], x1 = x[1], x2 = x[2], x3 = x[3];
      const sin_theta = Math.sin(theta);
      const sin_alpha = Math.sin(alpha);
      const q0 = Math.cos(alpha);
      const q1 = sin_theta * Math.cos(phi) * sin_alpha;
      const q2 = sin_theta * Math.sin(phi) * sin_alpha;
      const q3 = Math.cos(theta) * sin_alpha;
      return [
        q0 * x0 - q1 * x1 - q2 * x2 - q3 * x3,
        q1 * x0 + q0 * x1 + q3 * x2 - q2 * x3,
        q2 * x0 - q3 * x1 + q0 * x2 + q1 * x3,
        q3 * x0 + q2 * x1 - q1 * x2 + q0 * x3
      ];
    }

    // stereographic projection
    function stereoProj(x) {
      const d = vxnorm - x[3];
      return [x[0] / d, x[1] / d, x[2] / d];
    }

    // projected and rotated vertices
    function makeVertices3d(theta, phi, alpha) {
      let vertices3d = new Array(nvertices);
      for(let i = 0; i < nvertices; i++) {
        vertices3d[i] = new THREE.Vector3().fromArray(
          stereoProj(rotate4d(theta, phi, alpha, vertices4d[i]))
        );
      }
      return vertices3d;
    }

    // -- geometries ----------------------------------------------------------

    // unitCylinder is a cylinder such that:
    // - the center of the first base is (0, 0, 0)
    // - the center of the second base is (0, 0, 1)
    // it will be used to construct the edges
    const unitCylinder = new THREE.CylinderGeometry(1, 1, 1, 64, 1, true);
    unitCylinder.translate(0, 0.5, 0).rotateX(Math.PI * 0.5);

    // a sphere for plotting the vertices
    const sphere = new THREE.SphereGeometry(vertexRadius);

    // an empty tetrahedron
    const faces = [
      2, 1, 0,
      0, 3, 2,
      1, 3, 0,
      2, 3, 1
    ];
    let cell = new THREE.BufferGeometry();
    cell.setIndex(faces);
    cell.setAttribute(
      "position", new THREE.BufferAttribute(new Float32Array(4*3), 3)
    );

    // -- materials -----------------------------------------------------------
    const edgeMaterial = new THREE.MeshPhongMaterial({
      color: 0x156289,
      emissive: 0x072534,
      flatShading: true
    });
    const vertexMaterial = new THREE.MeshPhongMaterial({
      color: 0x1562ff,
      emissive: 0x0725ff,
      flatShading: true
    });
    const cellMaterial = new THREE.MeshPhongMaterial({
      color: 0x9900ff,
      emissive: 0xff05ff,
      transparent: true,
      opacity: 0.3,
      flatShading: true,
      dithering: true,
      side: THREE.DoubleSide
    });

  </script>  

</head>

<body>
  <div id="container"></div>

<script>
  // three js scene --------------------------------------------------------
  const aspect = window.innerWidth / window.innerHeight;
  let camera = new THREE.PerspectiveCamera(75, aspect, 1, 10000);
  camera.position.z = 6;
  let scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  scene.add(camera);
  let group = new THREE.Group();
  scene.add(group);

  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById("container").appendChild(renderer.domElement);

  function onWindowResize() {
    const windowX = window.innerWidth;
    const windowY = window.innerHeight;
    camera.aspect = windowX / windowY;
    camera.updateProjectionMatrix();
    renderer.setSize(windowX, windowY);
  }
  window.addEventListener("resize", onWindowResize);

  const lights = new Array(4);
  lights[0] = new THREE.PointLight(0xffffff, 1, 0);
  lights[1] = new THREE.PointLight(0xffffff, 1, 0);
  lights[2] = new THREE.PointLight(0xffffff, 1, 0);
  lights[3] = new THREE.PointLight(0xffffff, 1, 0);
  lights[0].position.set(0, 20000, 0);
  lights[1].position.set(0, -20000, 0);
  lights[2].position.set(10000, 20000, 10000);
  lights[3].position.set(-10000, -20000, -10000);
  scene.add(lights[0]);
  scene.add(lights[1]);
  scene.add(lights[2]);
  scene.add(lights[3]);

  function render() {
    renderer.render(scene, camera);
  }

  const controls = new THREE.OrbitControls(camera, renderer.domElement );
  controls.update();
  // --

  let Meshes_vertices = new Array(nvertices);
  let Meshes_edges = new Array(nedges);
  let Meshes_tetrahedra = new Array(ntetrahedra);

  function makeMeshes() {
    for(let i = 0; i < nvertices; i++) {
      let mesh = new THREE.Mesh(sphere, vertexMaterial);
      Meshes_vertices[i] = mesh;
      group.add(mesh);
    }
    for(let i = 0; i < nedges; i++) {
      let mesh = new THREE.Mesh(unitCylinder, edgeMaterial);
      mesh.scale.set(edgeRadius, edgeRadius, 1);
      Meshes_edges[i] = mesh;
      group.add(mesh);
    }
    for(let i = 0; i < ntetrahedra; i++) {
      let mesh = new THREE.Mesh(cell.clone(), cellMaterial);
      mesh.geometry.attributes.position.needsUpdate = true;
      Meshes_tetrahedra[i] = mesh;
      group.add(mesh);
    }
  }
  makeMeshes(); 

  window.requestAnimFrame = (function () {
    return (
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame 
    );
  })();

  // lil.gui controls ------------------------------------------------------
  let lgcontrols = {
    rotationSpeed: 50,
    theta: 0,
    phi: 0
  };
  const gui = new GUI({ autoplace: false, width: 310 });
  gui.domElement.id = "gui";
  gui
    .add(lgcontrols, "rotationSpeed")
    .min(1)
    .max(250)
    .step(3)
    .name("4d rotation speed");
  gui
    .add(lgcontrols, "theta")
    .min(0)
    .max(6.3)
    .step(0.1)
    .name("theta");
  gui
    .add(lgcontrols, "phi")
    .min(0)
    .max(3.2)
    .step(0.05)
    .name("phi");

  // -- animation -------------------------------------------------------------
  const alpha = Math.PI / 180;
  var k = 0;

  function animate() {
    setTimeout(function() {
      requestAnimFrame(animate);
    }, 1000 / lgcontrols.rotationSpeed);

    let vertices3d = makeVertices3d(
      lgcontrols.theta, lgcontrols.phi, k*alpha
    );

    for(let i = 0; i < nvertices; i++) {
      let mesh = Meshes_vertices[i];
      mesh.position.copy(vertices3d[i]);
    }

    for(let i = 0; i < nedges; i++) {
      const edge = edges[i];
      const vi = vertices3d[edge[0]];
      const vj = vertices3d[edge[1]];
      let mesh = Meshes_edges[i];
      mesh.position.copy(vi);
      mesh.scale.z = vi.distanceTo(vj);
      mesh.lookAt(vj);
    }

    for(let t = 0; t < ntetrahedra; t++) {
      let mesh = Meshes_tetrahedra[t];
      let tetrahedron = tetrahedra[t];
      let cellVertices = new Array(0);
      for(let i = 0; i < 4; i++) {
        let vi = vertices3d[tetrahedron[i]];
        cellVertices.push(vi.x, vi.y, vi.z);
      }
      mesh.geometry.setAttribute(
        "position", new THREE.Float32BufferAttribute(cellVertices, 3)
      );
      mesh.geometry.computeBoundingBox();
      mesh.geometry.computeBoundingSphere();
    }

    k++;

    controls.update();
    render();

  }

  animate();

</script>


</body>

</html>

